## 1、node的事件循环
在Node.js中编写代码时，经常会涉及到异步操作，比如文件读写、网络请求、数据库操作等。Node.js采用了事件驱动的模型，通过事件循环来管理和处理这些异步操作。

**事件循环执行过程：**

执行前，会先执行同步任务、再执行process.nextTick 、微任务 ，等所有微任务队列全部执行完后，才进入事件循环event-loop的timers阶段。

（事件循环的队列主要有timer queue，poll queue，check queue，close queue）

- **进入 event-loop**
- **进入 timers 阶段**：处理通过setTimeout()和setInterval()设置的定时器任务。当定时器到达指定的时间时，事件循环将进入下一个阶段。
- 进入 pending callbacks阶段：执行系统操作的回调。如tcp,udp通信的错误callback
- 进入 idle，prepare 阶段：该阶段在内部使用。
- **进入 poll 阶段**：处理异步I/O操作的回调函数，比如文件读写、网络请求的回调函数。当这些异步操作完成时，相关的回调函数会被添加到事件循环的I/O队列中。

轮询阶段（Poll queue）：此阶段是Node.js事件循环的核心。在此阶段：

Node.js会检查是否有待处理的I/O事件回调函数，如果有，将其移至下一个阶段。

Node.js会检查timer队列是否有任务，有的话进入timer队列执行timer回调；

Node.js会检查check队列是否有setImmediate()回调任务，有的话进入check队列执行回调；

如果没有I/O事件回调函数，poll队列是空的，timer队列和check队列也是空的，Node.js会在poll队列暂停，以等待新的I/O事件的到来。


![](@alias/da63df50e47e4db2acc40af9181e2e12.png)
- **进入 check 阶段**：
在此阶段执行setImmediate()回调函数。setImmediate()函数用于注册在事件循环的下一个轮询阶段之前执行的回调函数。
- **进入 closing 阶段**。
处理关闭事件的回调函数，如socket.on('close')
- 检查是否有活跃的 handles（定时器、IO等事件句柄）。
  如果有，继续下一轮循环。
  如果没有，结束事件循环，退出程序。

## 2、Node.js如何克服I/O操作阻塞的问题 ？
**其一，异步回调函数**，大部分的 API 都是基于异步回调函数的形式提供的。在处理 I/O 操作时，不需要等待操作完成，
而是定义一个回调函数来处理返回结果，从而实现非阻塞的操作。

**其二，利用事件循环**，Node.js 的事件循环会持续地监视已发起的 I/O 操作，当某个 I/O 操作完成时，会触发相应的事件，然后执行相应的回调函数来处理结果。

而且，事件循环是按照顺序完成异步操作的，先执行process.nextTick和微任务，然后再执行事件循环的timer queue，poll queue，check queue，close queue。
当事件循环所有队列清空时，会在poll队列暂停，以等待新的IO事件。这种方式可以充分利用 CPU 的资源，避免了线程被阻塞等待 I/O 完成的问题。

可用于以异步方式处理所有 I/O 操作，而不会阻塞 main 函数。

例如，如果需要进行一些网络调用，它将被安排在事件循环中，而不是主线程（单线程）中。

如果有多个这样的 I/O 调用，每个调用都会相应地排队分别执行（除了主线程）。

因此，即使我们有单线程 JS，I/O 操作也是以非阻塞方式处理的

## 3、Node.js 有哪些常用的计时特性 ？
- **setTimeout**：setTimeout 函数用于在指定的延迟时间之后执行一次回调函数。它接受两个参数，第一个参数是要执行的回调函数，第二个参数是延迟的毫秒数。
- **setInterval**：setInterval 函数用于按照指定的时间间隔重复执行回调函数。它接受两个参数，第一个参数是要执行的回调函数，第二个参数是重复执行的时间间隔的毫秒数。
- **setImmediate**：setImmediate 函数用于在当前事件循环的下一个tick迭代中执行回调函数。它的执行优先级要高于 setTimeout。
- **process.nextTick**：process.nextTick 方法可用于在当前事件循环迭代的末尾立即执行回调函数。它的执行优先级要高于 setImmediate。使用 process.nextTick 可以使回调函数尽快执行，并允许在执行长时间运行的操作之前执行其他微任务。
- **clearImmediate**：clearImmediate 函数用于取消通过 setImmediate 创建的定时器。
- **clearTimeout**：clearTimeout 函数用于取消通过 setTimeout 创建的定时器。
- **clearInterval**：clearInterval 函数用于取消通过 setInterval 创建的定时器。

## 4、说说Node中的fs模块的理解？有哪些常用的方法
fs 模块是核心模块之一，用于操作文件系统。它提供了一系列的方法，用于进行文件的读取、写入、修改、删除等操作。
- **fs.readFile (path[, options], callback)**：用于异步地读取文件的内容。它接受文件路径 path、可选的编码选项 options 和回调函数 callback。
- **fs.readFileSync (path[, options])**：用于同步地读取文件的内容。与 fs.readFile 不同，它会阻塞执行，直到文件读取完成或出现错误。
- **fs.writeFile (file, data[, options], callback)**：用于异步地将数据写入文件。
- **fs.writeFileSync (file, data[, options])**：用于同步地将数据写入文件。与 fs.writeFile 不同，它会阻塞执行，直到写入完成或出现错误。
- **fs.appendFile (file, data[, options], callback)**：用于异步地追加数据到文件末尾。
- **fs.appendFileSync (file, data[, options])**：用于同步地追加数据到文件末尾。与 fs.appendFile 不同，它会阻塞执行，直到追加完成或出现错误。
- **fs.unlink(path, callback)**：用于异步地删除文件。它接受文件路径 path 和回调函数 callback。
- **fs.unlinkSync(path)**：用于同步地删除文件。与 fs.unlink 不同，它会阻塞执行，直到文件删除成功或出现错误。它接受文件路径 path。
- **fs.copyFile**：文件异步拷贝
- **fs.copyFileSync**：文件拷贝


## 5、说说对Node中的Buffer的理解？应用场景？
Buffer 是用于处理二进制数据的类。它是一个全局对象，不需要通过 require 直接就可以使用

Buffer 可以用来存储和操作各种形式的数据，如图片、音视频文件、网络数据

【应用场景】：

- I/O文件操作：通过流的形式，将一个文件的内容读取到另外一个文件
- 网络通信：在进行网络通信时，常常需要处理二进制数据，如传输文件、处理网络协议等。Buffer 可以用于接收和发送数据，以及对数据进行编码和解码。
- 压缩与解压
- 加密解密：加密算法通常需要直接操作二进制数据。Buffer 提供了对数据进行加密和解密所需的方法，如创建密钥、加密数据、解密数据等。
- 图片处理：Buffer 可以用于处理图片数据，如读取、修改、缩放、剪裁、合成等各种操作。很多图片处理库和框架都使用 Buffer 来处理图像数据。

## 6、说说对Node中的Strem的理解？应用场景？
Stream（流）是一种用于处理输入和输出数据的抽象概念。它允许将数据分割成一系列小块进行处理，而不是一次性将整个数据加载到内存中，可以地处理大量数据、实时数据和流式数据，同时提供了高效的内存使用和处理速度。它在文件操作、网络通信、数据处理和实时日志等场景中被广泛应用。

- **文件操作**： Stream 可以用于读取和写入文件。通过流式读取文件，可以逐块地读取大型文件而不必一次性加载整个文件到内存中。类似地，可以使用流式写入来减少内存占用，并支持实时写入大量数据。
- **网络通信**： 在网络通信中，Stream 可以用于处理请求和响应数据。HTTP 请求和响应都可以使用流进行发送和接收，允许边接收边处理数据，极大地提高了网络通信的效率。
- **数据转换和处理**： Stream 提供了丰富的数据转换和处理功能。通过使用不同类型的流（如可写流、可读流和转换流等），可以对数据进行各种操作，如压缩、解压缩、加密、解密、解析、转码等。
- **实时日志**： 使用流可以非常方便地处理实时生成的日志数据。可以将日志通过流式输入到文件、数据库或其他存储位置，同时可以对日志进行实时处理、筛选、过滤等。
- **图片和音视频处理**： 对于大型的图片、音频和视频文件，使用流可以有效地处理。通过流，可以逐帧地读取和处理媒体数据，如缩放、剪裁、转码、合成等。
- **数据流分析**： 当需要对大量数据进行分析、统计和处理时，使用流可以提高效率。数据流可以用于实时数据分析、批量数据处理、数据清洗等场景。

由此看出，Buffer 适合于一次性处理固定大小的数据块，而 Stream 更适合于处理连续的数据流或大型数据
## 7、说说你对nodejs里中间件概念的理解，作用，场景有哪些？
中间件函数可以被插入到 HTTP 请求处理流程中，以接收和处理请求对象(req)和响应对象(res)，并可以对它们进行各种操作。

中间件的作用是在请求被处理之前、期间或之后执行一些特定的逻辑。它可以用于实现各种功能，如路由处理、身份验证、日志记录、错误处理等。中间件充当了服务器和应用程序之间的桥梁，可以对请求和响应进行干预和处理。
- **路由处理**： 中间件可以用于处理不同的路由请求。基于路径、方法或其他条件，中间件可以将请求路由到不同的处理函数中，实现灵活的路由控制。
- **身份验证和权限控制**： 中间件可以用于验证用户的身份和检查权限。在接收到请求后，中间件可以验证用户的凭据，并根据其权限级别决定是否允许继续执行请求。
- **错误处理**： 中间件可以捕获异常并处理错误。在应用程序中，可以插入一个中间件来捕获错误，并返回相应的错误响应，以提高应用程序的健壮性和稳定性。
- **日志记录**： 中间件可以用于记录请求和响应的日志信息。通过插入一个日志中间件，可以记录请求的详细信息，如请求路径、HTTP 方法、请求参数等，以及响应的状态码、响应时间等。
- **数据转换和处理**： 中间件可以用于转换和处理请求和响应的数据。例如，可以插入一个中间件来解析请求的 JSON 数据或处理响应的数据格式。
## 8、用过nodejs的什么框架，为什么用express框架，有什么优点
express、koa、egg、nest、midway都是常见的nodejs开源框架。
其关系，基本如下：
```js
Midway.js ---|> Egg.js ---|> Koa.js,
               Nest.js ---|> Express.js
```
而koa实际上是express团队用新理念重写的，从架构上讲，更加先进一些。

midway.js和egg.js背后都是阿里的团队，其架构基于koa。

nest.js背后是国外的Trilon团队，其架构基于express
### (1) Koa
koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 generator，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。

koa是一个拥有洋葱模型中间件的http处理库，一个请求，经过一系列的中间件，最后生成响应。Koa的大致实现原理：context上下文的保存和传递，中间件的管理和next方法的实现。

所以koa的开发过程中，往往要引用他人开发的中间件，或是自己开发中间件，然后再开发业务逻辑。

Koa和Express之间的主要区别在于它们处理中间件的方式。Express在应用程序框架中包括路由和模板。另一方面，Koa需要具有这些功能的模块，因此使其更具模块化或可定制性。
```js
const Koa = require('koa');
const app = new Koa();
app.use(async ctx => {
  ctx.body = 'Hello World';
});
app.listen(3000, () => console.log('Koa is listening to http://localhost:3000'));
```
Node的req和res对象已被Koa的Context对象替换。该对象包括ctx.request和ctx.response属性。

**Koa的路由：**

Koa不提供任何内置的路由中间件，因此您必须安装类似koa-router的模块。

**Koa的优点：**

使用Koa，由于该框架具有灵活性，因此更容易编写中间件。它被设计为既使写作又使阅读愉快。它还使用ES6异步/等待功能来消除对回调的使用。另一个重要的考虑因素是Koa的下载量很小。它非常轻巧，大约有500行代码。

**Koa的缺点：**

虽然Koa可能是新的，但它也比其较旧的兄弟版Express不稳定。相比之下，开源社区也要小得多，这意味着可用的支持较少。尽管async / await消除了对回调的需求，但一次多个异步调用仍可能导致async / await hell。Koa特定的中间件也与其他框架不兼容。

```js
const Koa = require('koa');
const Router = require('koa-router');
const app = new Koa();
const router = new Router();
router
  .get('/', (ctx, next) => {
    ctx.body = 'Hello World!';
  })
  .post('/users', (ctx, next) => {
    // …
  .put('/users', (ctx, next) => {
    // …
  .del('/users', (ctx, next) => {
    // …
  });
app
  .use(router.routes())
  .use(router.allowedMethods());
```
有了Koa，这是一个简单的路由器。如果请求/响应周期中存在错误，则内置错误处理功能，这意味着它将所有错误输出到stderr。
### (2) Express
Express 是一个保持最小规模的灵活的 Node.js Web 应用程序开发框架，为 Web 和移动应用程序提供一组强大的功能。

使用Express，路由也相对简单。使用app.route，您可以将路径的路由处理程序链接在一起，同时保持代码DRY。

尽管Express有其广泛的优点，但并非没有缺点。从根本上讲，这是非常劳动密集型的。它要求开发人员手动创建所有端点，这意味着代码库越大，重构就越困难。随后，您需要有条理地维护代码，因为很容易在所有中间件中迷失方向。它还没有像Koa和Hapi这样的内置错误处理。
### (3) midway
MidwayJS 是阿里巴巴开源的 Node.js 服务端框架，它基于 Egg 和 TypeScript 封装而成，提供了更加完善的依赖注入、ORM、GraphQL 等功能，适合大型企业级项目的开发。MidwayJS 的优点是功能强大、易于扩展、性能稳定，缺点是相对于其他框架来说，学习成本稍高
### (4) egg
Egg 是阿里巴巴开源的企业级 Node.js 框架，它基于 Koa 封装而成，提供了更加完善的插件机制、多进程管理、插件热更新等功能，适合大型项目的开发。Egg 的优点是功能强大、易于扩展、性能稳定，缺点是相对于 Express 和 Koa 来说，学习成本稍高
### (5) nest
NestJS 是一个基于 TypeScript 和 Express 的 Web 框架，它提供了类似于 Angular 的依赖注入、模块化、面向切面编程等功能，适合大型企业级项目的开发。NestJS 的优点是代码结构清晰、易于维护、可测试性强，缺点是相对于其他框架来说，学习成本稍高。
