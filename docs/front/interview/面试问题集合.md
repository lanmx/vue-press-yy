## 1. js精度丢失

```js
parseFloat(num.toPrecision(12))
```

## 2. 防抖和节流

- 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效
- 防抖: n 秒后在执行该事件，若在 n 秒内被重复触发，则重新计时

#### （1）防抖

事件响应函数在一段时间后才执行，如果在这段时间内再次调用，则重新计算时间；当预定的时间内没有调用该函数，则执行；

```js
// true为立即执行
function debounce(fn,dalay,immediate) {
    let timer;
    return function() {
        clearTimeout(timer)
        if(immediate) {
            fn.apply(this, arguments)
        } else {
            timer = setTimeout(() => {
                fn.apply(this, arguments)
            }, delay)
        }
        
    }
}
```

#### （2）节流

```js
  const throttled = function (fn, delay) {
    let timer = null
    return function() {
      if(!timer) {
        timer = setTimeout(() => {
          fn.call(this, arguments)
          timer = null
        }, delay)
      }
    }
  }
```

#### （3）应用

防抖在连续的事件，只需触发一次回调的场景有：

- 搜索框搜索输入。只需用户最后一次输入完，再发送请求
- 手机号、邮箱验证输入检测
- 窗口大小`resize`。只需窗口调整完成后，计算窗口大小。防止重复渲染。

节流在间隔一段时间执行一次回调的场景有：

- 滚动加载，加载更多或滚到底部监听
- 搜索框，搜索联想功能

#### （4）实操代码

```js
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .class-style {
      width: 100%; 
      height: 60px;
      text-align: center;
    }
  </style>
</head>
<body>
  <div>
    <div onmouseover="over()" class="class-style" style="background-color: tomato; ">onmouseover</div>
    <div onmouseout="out()" class="class-style" style="background-color: yellow; ">onmouseout</div>
    <div onmouseleave="leave()" class="class-style" style="background-color: burlywood; ">onmouseleave</div>
    <div onmouseenter="enter()" class="class-style" style="background-color: paleturquoise; ">onmouseenter</div>
    <div id="dom" onmousemove="move()" class="class-style" style="background-color: pink; "></div>
    <div id="dom2" onmousemove="move2()" class="class-style" style="background-color: yellowgreen; "></div>
    <div id="dom3" onmousemove="move3()" class="class-style" style="background-color: plum; "></div>
    <div id="dom4" onmousemove="move4()" class="class-style" style="background-color: paleturquoise; "></div>
  </div>
</body>
<script>
  // 节流: 时间截的方法: 事件停止触发不再执行
  const throttled1 = function (fn, delay) {
    let oldTime = Date.now()
    return function() {
      let newTime = Date.now()
      if(newTime - oldTime > delay) {
        fn.call(this, arguments)
        oldTime = Date.now()
      }
    }
  }
   // 节流: 定时器的方法：第二次事件停止触发，依然会再执行一次
  const throttled2 = function (fn, delay) {
    let timer = null
    return function() {
      if(!timer) {
        timer = setTimeout(() => {
          fn.call(this, arguments)
          timer = null
        }, delay)
      }
    }
  }
  // 节流：时间戳 + 定时器，实现一个更加精确的节流
  const throttled3 = function (fn, delay) {
    let timer = null
    let oldTime = Date.now()
    return function () {
      let newTime = Date.now()
      clearTimeout(timer)
      if(newTime - oldTime > delay) {
        fn.call(this, arguments)
        oldTime = Date.now()
      } else {
        timer = setTimeout(fn, newTime - oldTime)
        // timer = setTimeout(() => {
        //   fn.call(this, arguments)
        // }, newTime - oldTime)
      }
    }
  }
  // 防抖
  const debounce = function (fn, delay, immediate) {
    let timer = null
    return function() {
      if(timer) clearTimeout(timer)
      if(immediate) {
        // 立即执行
        // 第一次会立刻执行，以后只有在事件执行后才会再次触发
        let callnow = !timer
        timer = setTimeout(() => {
          timer = null
        }, delay)
        if(callnow) {
          fn.apply(this, arguments)
        }
      } else {
        timer = setTimeout(() => {
          fn.apply(this, arguments)
        }, delay)
      }
    }
  }
  let count = 0
  const over = function() {
    console.log(this)
    console.log("over")
  }
  const out = function() {
    console.log(this)
    console.log("out")
  }
  const leave = function() {
    console.log(this)
    console.log("leave")
  }
  const enter = function() {
    console.log(this)
    console.log("enter")
  }
  const move = debounce(function() {
    count++
    let dom = document.getElementById('dom')
    dom.innerHTML = '鼠标移动防抖：' + count
    console.log(count)
    // console.log(this)
  }, 500)
  const move2 = throttled1(function() {
    count++
    let dom = document.getElementById('dom2')
    dom.innerHTML = '鼠标移动时间戳节流：' + count
  }, 500)
  const move3 = throttled2(function() {
    count++
    let dom = document.getElementById('dom3')
    dom.innerHTML = '鼠标移动定时器节流：' + count
  }, 500)
  const move4 = throttled3(function() {
    count++
    let dom = document.getElementById('dom4')
    dom.innerHTML = '鼠标移动时间戳 + 定时器节流：' + count
  }, 500)
</script>
</html>
```



## 4. vue中v-for的key用法和原理

#### （1）为什么在v-for中用key

- 使用key的原因和vue虚拟DOM的diff算法有关，虚拟DOM渲染成真实DOM，会进行新旧节点比较，这里比较就用到diff算法；diff算法使用key作为vNode节点的唯一标识，通过key，Diff算法可以更准确， 更快的找到对应的vnode节点，进行patch比较修补丁；
- Vue会尽可能高效的渲染元素，通常会复用已有的元素，而不是从头开始渲染
- Vue提供一种方式来表达这两个元素时完全独立的，如果不要复用它们。只需要添加一个具有唯一值的key属性即可。

#### （2）为什么key不建议用index

key绑定的值建议是唯一的标识，因为index可能会变，例如，如果我删掉数组长度为5的第4个元素，第5个元素的索引index会变为4；也就是key变了，根据vue虚拟Dom的算法，会通过key去判断，判断到这个key不一样，就不会走sameNodes的代码，会删除节点或者新建节点；

#### （3）diff算法

vue中，虚拟 dom 渲染成真实 dom 的新旧 VNode 节点比较用到diff算法

diff 算法是一种通过同层的树节点进行比较的高效算法

其有两个特点：

- 比较只会在同层级进行, 不会跨层级比较
- 在diff比较的过程中，循环从两边向中间比较

**patchVnode方法：**

- 当数据发生改变时，订阅者watcher就会调用patch给真实的DOM打补丁

- 通过isSameVnode进行判断，相同则调用patchVnode方法

- patchVnode做了以下操作：
  - 找到对应的真实dom，称为el
  - 如果都有都有文本节点且不相等，将el文本节点设置为Vnode的文本节点
  - 如果oldVnode有子节点而VNode没有，则删除el子节点
  - 如果oldVnode没有子节点而VNode有，则将VNode的子节点真实化后添加到el
  - 如果两者都有子节点，则执行updateChildren函数比较子节点
- updateChildren主要做了以下操作：
  - 设置新旧VNode的头尾指针
  - 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用patchVnode进行patch重复流程、调用createElem创建一个新节点，从哈希表寻找 key一致的VNode 节点再分情况操作，直到旧节点的头指针大于尾指针的时候就退出循环。

## 5. 说说axios请求

## 6. eventBlus事件总线

## 7. 只用watch，不用computed监听对象

#### （1）computed

惰性求值；computed的值在getter执行后是会被缓存的。如果所依赖的数据发生改变时候，就会重新调用getter来计算最新的结果。

而且计算属性的值是会被缓存的，只有当依赖的响应式数据更新后才会被重新计算求值。

#### （2）watch

watch用于侦听data的数据。watch属性可以是字符串、函数、对象、数组

当data数据发生变化，执行函数。在函数中会传入newVal和oldVal两个参数。

这因为watch不会监听第一次变化，可以通过immediate：true开启

拥有deep，immediate两属性：

- 当deep：true 会监听到obj对象的所有内部属性，默认值为false

- 当 immediate：true 时，回调函数会在监听开始后立刻执行，可以监听到到第一次变化。

#### （3）watch和computed的区别

- watch可以异步，computed不支持异步
- watch没有依赖缓存特性，computed有缓存机制，惰性计算，当依赖的数据更新时才会执行getter函数
- watch一对多；computed多对一或一对一
- watch有两个参数和两个属性，computed通过get和set



## 8. watch和computed的生命周期阶段

所以watch和computed的初始化是在created之前，beforeCreate之后。

```javascript
initLifecycle(vm)       // 初始化生命周期
initEvents(vm)        // 初始化事件
initRender(vm)         // 初始化渲染
callHook(vm, 'beforeCreate')  // 调用生命周期钩子函数
initInjections(vm)   //初始化injections
initState(vm)    // 初始化props,methods,data,computed,watch
initProvide(vm) // 初始化 provide
callHook(vm, 'created')  // 调用生命周期钩子函数
```

如果是父组件的值改变了props给子组件的值，同时触发了父组件和子组件watch和computed，那么执行顺序可以是：

methods => 父watch => 父computed => 子watch => 子computed

![image-20220217154607121](@alias/image-20220217154607121.png)

## 9. cookie

浏览器发起HTTP请求，服务器进行cookie设置，也就是Set-Cookie，Set-Cookie HTTP头作为请求的一部分，通过name=value形式存储在浏览器；每次发送HTTP请求的时候都会发送cookie到服务器；

说白了，cookie是保存在浏览器的，很不安全，然后就有了session会话。

session 是另一种记录服务器和客户端会话状态的机制，session 是基于 cookie 实现的，session 存储在服务器端，sessionId 会被存储到客户端的cookie 中。

浏览器访问服务器就是会话的开始，服务器设定会话的结束时间和session ID，发送给浏览器，用户每次请求的时候都自动发送请求保存session的cookie，直到结束时间到了，需要重新登录。

SessionID 是连接 Cookie 和 Session 的一道桥梁。

![session.png](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/29/16f523a04d0b3cf5~tplv-t2oaga2asx-watermark.awebp)

缺点：大量用户登录的时候，服务器需要保存大量的session ID，如果有多台服务器，也需要服务器之间进行共享。

#### （1）token

Token:  令牌， 是访问资源的凭证

Token的认证流程：

1. 用户输入用户名和密码，发送给服务器。

2. 服务器验证用户名和密码，正确的话就返回一个签名过的token（token 可以认为就是个长长的字符串），浏览器客户端拿到这个token。

3. 后续每次请求中，浏览器会把token作为http header发送给服务器，服务器验证签名是否有效，如果有效那么认证就成功，可以返回客户端需要的数据。

#### （2）JSON Web Token （JWT）: 可解决跨域

用户登录可以用token来认证该用户是否登录。jwt也是经常作为一种安全的token使用。

JWT是`json web token`缩写。它将用户信息加密到token里，服务器不保存任何用户信息。服务器通过使用保存的密钥验证token的正确性，只要正确即通过验证。

- 服务器第一次登录网页，服务器会生成一个JWT，服务器不需要保存JWT，只需要保存JWT的签名
- 服务器将JWT发送给浏览器，可以让浏览器一cookie或者storage的形式保存下来
- 每次请求的时候浏览器会自动把JWT发送给浏览器，用户不用再次登录

JWT三部分组成：

[JWT 的数据结构](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)

- header

  每个JWT都会带有头部信息，这里主要声明使用的算法。声明算法的字段名为alg，同时还有一个typ的字段，默认JWT即可。以下示例中算法为HS256

  ```js
  {  
      "alg": "HS256",   // 算法声明
      "typ": "JWT"   // 加密类型
  } 
  ```

- payload

  载荷即消息体，这里会存放实际的内容，也就是Token的数据声明，例如用户的id和name，默认情况下也会携带令牌的签发时间iat，通过还可以设置过期时间

  ```js
  {
    "sub": "1234567890",
    "name": "John Doe", // 用户名
    "iat": 1516239022,  // 签发时间
    "exp": 1816239022,  // 过期时间
  }
  ```

  > iss (issuer)： 签发人
  > sub (subject)： 主题
  > aud (audience)： 受众
  > exp (expiration time)： 过期时间
  > nbf (Not Before)： 生效时间，在此之前是无效的
  > iat (Issued At)： 签发时间
  > jti (JWT ID)： 编号

- signature

  签名是对头部和载荷内容进行签名，一般情况，设置一个secretKey，对前两个的结果进行HMACSHA25算法，公式如下：

  ```js
  Signature = HMACSHA256(base64Url(header)+.+base64Url(payload),secretKey)
  
  ```

  一旦前面两部分数据被篡改，只要服务器加密用的密钥没有泄露，得到的签名肯定和之前的签名不一致

![image-20220217165334264](@alias/image-20220217165334264.png)

客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。

此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。

**JWT优缺点**

优点：

- json具有通用性，所以可以跨语言
- 组成简单，字节占用小，便于传输
- 服务端无需保存会话信息，很容易进行水平扩展
- 一处生成，多处使用，可以在分布式系统中，解决单点登录问题
- 可防护CSRF攻击

缺点：

- payload部分仅仅是进行简单编码，所以只能用于存储逻辑必需的非敏感信息
- 需要保护好加密密钥，一旦泄露后果不堪设想
- 为避免token被劫持，最好使用https协议



#### （3）JWT和token的区别

token需要查库验证token 是否有效，而JWT不用查库或者少查库，直接在服务端进行校验，并且不用查库。因为用户的信息及加密信息在JWT的第二部分payload和第三部分签证中已经生成，只要在服务端进行校验判断签名是否正确就行，并且校验也是JWT自己实现的。

#### （4）session、cookie、token区别

session时服务器生成的，服务器主导一切

cookie是保存session的载体，跟随HTTP请求发送出去

token是诞生在服务器，保存在浏览器，可以保存在cookie或者storage里面

[分清 Cookie、Session、Token、JWT](https://juejin.cn/post/6844904034181070861)

## 9. vue中如何收集依赖

每一个属性都有一个dep，存放所依赖的watcher，当属性变化后会通知对应的watcher去更新

在渲染的时候，get获取这个响应式数据，此时就会触发收集依赖的dep.depend()

当数据发生改变时，会触发watcher，通过dep.notify()去更新数据

## 10. 闭包的理解，应用场景？

防抖和节流用的闭包实现

```js
var fnArr = []
for(var i = 0; i < 10; i++) {
    fnArr[i] = function() {
        return i
    }
}
```

## 11. try...catch

## 12. vue2如何检测数组的变化

vue2没有用defineProperty对数组拦截，而是对数组重写，数组中如果是对象的数据类型，用defineProperty，再继续递归处理；数组的索引和长度是无法监控的；

## 13. Vue为什么要用虚拟DOM

减少DOM操作，提高性能

## 14. nextTick原理

nextTick的回调函数在下一次DOM更新循环结束执行回调，用于获取更新后的DOM；

vue中的数据更新是异步的，使用nextTick可以保证拿到更新后的数据做逻辑处理；

例如修改了三个变量，是每修改一次，DOM就更新一次吗？不是的，Vue采用的是异步更新的策略，通俗点说就是，同一事件循环内多次修改，会统一进行一次视图更新。

## 15. 树级结构转换为一维结构

手写代码，用两种解法实现

```js
  // 解法一：递归, 使用reduce + concat
  {
    let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
    const newArr = function(arr){
      return arr.reduce((pre,cur)=>pre.concat(Array.isArray(cur)?newArr(cur):cur),[])
    }
    console.log(newArr(arr)); //[0, 1, 2, 3, 4, 5, 6, 7]
  }
  // 解法二：递归, 使用forEach + push
  {
    let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
    let newArr = []
    const flatArr = function(arr) {
      arr.forEach(item => {
        Array.isArray(item) ? flatArr(item) : newArr.push(item)
      })
    }
    flatArr(arr);
    console.log(newArr)
  }
  // 解法三：使用flat,es10语法
  {
    let arr = [[0, 1], [2, 3], [4,[5,6,7]]]
    let flatArr = arr.flat(3)
    console.log(flatArr)
  }
```



## 16. webpack的热更新

`HMR`全称 `Hot Module Replacement`，可以理解为模块热替换，指在应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个应用

例如，我们在应用运行过程中修改了某个模块，通过自动刷新会导致整个应用的整体刷新，那页面中的状态信息都会丢失

如果使用的是 `HMR`，就可以实现只将修改的模块实时替换至应用中，不必完全刷新整个应用

`webpack.config.js`配置

```js
const webpackMerge = require('webpack-merge')
const baseconfig = require('./base.config')
module.export = webpackMerge(baseconfig, module.export = {
  devServer: {
    contentBase: './dist',
    inline: true,
    hot: true // 开启热更新
  }
})
```

通过上述这种配置，如果我们修改并保存`css`文件，确实能够以不刷新的形式更新到页面中

但是，当我们修改并保存`js`文件之后，页面依旧自动刷新了，这里并没有触发热模块

所以，`HMR`并不像 `Webpack` 的其他特性一样可以开箱即用，需要有一些额外的操作

`./src/index.js`配置

```js
// ...
if (module.hot) {
  module.hot.accept(['./content.js'], () => {
    render()
  })
}
```

![core](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAxOS85LzIvMTZjZjIwMzgyNDM1OTM5Nw?x-oss-process=image/format,png)

如上图所示，右侧Server端使用webpack-dev-server去启动本地服务，内部实现主要使用了webpack、express、websocket。

使用express启动本地服务，当浏览器访问资源时对此做响应。
服务端和客户端使用websocket实现长连接
webpack监听源文件的变化，即当开发者保存文件时触发webpack的重新编译。

每次编译都会生成hash值、已改动模块的json文件、已改动模块代码的js文件
编译完成后通过socket向客户端推送当前编译的hash戳
客户端的websocket监听到有文件改动推送过来的hash戳，会和上一次对比

一致则走缓存
不一致则通过ajax和jsonp向服务端获取最新资源
使用内存文件系统去替换有修改的内容实现局部刷新

## 17. webpack proxy代理

（本地开发请求另一个服务器的资源会因为浏览器安全策略的问题跨域，可以利用中间服务器实现代理，把请求转交给代理服务器，代理服务器响应请求，并把请求转交给目标服务器，目标服务器响应数据后返回给代理服务器，代理服务器再转交给本地。解决浏览器跨域的问题。）

`webpack proxy`，即`webpack`提供的代理服务

基本行为就是接收客户端发送的请求后转发给其他服务器

其目的是为了便于开发者在开发模式下解决跨域问题（浏览器安全策略限制）

想要实现代理首先需要一个中间服务器，`webpack`中提供服务器的工具为`webpack-dev-server`

`proxy`工作原理实质上是利用`http-proxy-middleware` 这个`http`代理中间件，实现请求转发给其他服务器。

#### webpack-dev-server

`webpack-dev-server`是 `webpack` 官方推出的一款开发工具，将自动编译和自动刷新浏览器等一系列对开发友好的功能全部集成在了一起

```js
const path = require('path')

module.exports = {
    // ...
    devServer: {
        contentBase: path.join(__dirname, 'dist'),
        compress: true,
        port: 9000,
        proxy: {
            '/api': {
                target: 'https://langding.fandow.com/', // 接口域名
				changeOrigin: true, // 请求头中host会设置成target 可通过request.getHeader("Host")拿到真实的接口域名
				ws: true, // 代理websocket
				rewrite: pathStr => pathStr.replace("/api", ""), // 重写路径
            }
        }
        // ...
    }
}

```

- target：表示的是代理到的目标地址
- pathRewrite：默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite
- secure：默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false
- changeOrigin：它表示是否更新代理后请求的 headers 中host地



在开发阶段， `webpack-dev-server` 会启动一个本地开发服务器，所以我们的应用在开发阶段是独立运行在 `localhost`的一个端口上，而后端服务又是运行在另外一个地址上

所以在开发阶段中，由于浏览器同源策略的原因，当本地访问后端就会出现跨域请求的问题

通过设置`webpack proxy`实现代理请求后，相当于浏览器与服务端中添加一个代理者

当本地发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地

![img](https://static.vue-js.com/65b5e5c0-ace5-11eb-85f6-6fac77c0c9b3.png)

在代理服务器传递数据给本地浏览器的过程中，两者同源，并不存在跨域行为，这时候浏览器就能正常接收数据

注意：**服务器与服务器之间请求数据并不会存在跨域行为，跨域行为是浏览器安全策略限制**





```js
const express = require('express');
const proxy = require('http-proxy-middleware');

const app = express();

app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true}));
app.listen(3000);

// http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/ba
```



## 18. css垂直居中

- 父元素没有高度，可以用margin

- 父元素有高度，可以用line-height等于父元素高度；如果用p标签则需要把margin: 0；因为p标签默认有margin值；line-height适用控制单行文字

- 父元素有固定高度，有多行文字，可以给父元素设置弹性布局；

  ```js
  display: flex;
  justify-content: center;
  align-items: center;
  ```

  

- ul li标签的标题可以用table，建议用flex

  ```js
  ul {
      display: table
  }
  li {
      display: table-cell;
      vertical-align: middle
  }
  ```

- grid建议用来做多行多列布局

  ```js
  ul {
      display: grid;
     justify-content: center;
     align-items: center;
  }
  ```
  


## 19. flex

- 父元素开启flex

```css
display:flex
display:inline-flex  行内元素
```

#### 父元素属性

#### （1）flex-direction

- 主轴叉轴方向 main cross

```css
flex-direction: row/row-reverse,主轴方向改变
flex-direction: coloum/coloum-reverse,从下到上
```

#### （2）justify-content（main方向）

-   justify-content: space-evenly

![image-20220219105746261](@alias/image-20220219105746261.png)

- justify-content: space-between;

![image-20220219105759918](@alias/image-20220219105759918.png)

- justify-content: space-around;

![image-20220219105818974](@alias/image-20220219105818974.png)

- justify-content: center;

![image-20220219110001845](@alias/image-20220219110001845.png)

![image-20220219105933768](@alias/image-20220219105933768.png)

#### （3）align-items（单行）（cross方向）

决定了flex items在cross axios的对齐方式

- normal(类似stretch)：拉伸
- flex-start
- flex-end
- center
- baseline以基准线对齐，第一行为准，例如文字第一行文字对齐

#### （4）align-content（多行）（cross方向）

- flex-start

- flex-end

- center

- space-between

- space-evenly

- space-around

#### （5）flex-wrap

- wrap
- nowrap

#### 项目属性

flex是flex-grow（放大），flex-shrink（缩小），flex-basis（宽度）三个属性值的缩写

默认值为 flex: 0 1 auto; 后两个属性可选 

#### （1）order

从大到小排序

#### （2）align-self

align-self:  flex-end覆盖flex-container的align-items

#### （3）flex-grow

均设1，则扩大，总和大余1，则平均，按比例扩大

#### （4）flex-shrink

按比例缩小

#### （5）flex-basis

flex-basis的优先级高于width



## 20. rem和em

在css中单位长度用的最多的是px、em、rem，这三个的区别是：

- px是固定的像素，px是相对长度单位，它是相对于显示器屏幕分辨率而言的，比较稳定和精确，但在浏览器中放大或缩放浏览页面时会出现页面混乱的情况，一旦设置了就无法因为适应页面大小而改变。

- em是相对长度单位，em是相对于父元素来设计字体大小的。如果当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺；em的值并不是固定的，它会继承父级元素的字体大小。

- rem是CSS3新增的一个相对单位，rem是相对单位，是相对HTML根元素。

  这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应。

- em和rem相对于px更具有灵活性，他们是相对长度单位，意思是长度不是定死了的，更适用于响应式布局。对于em和rem的区别一句话概括：em相对于父元素，rem相对于根元素。

rem中的r意思是root（根源），这也就不难理解了。

默认的情况下：1em=16px

## 21. 手写自定义指令，说说如何实现的

#### （1）自定义指令钩子函数

1. bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。
2. inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。
3. update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。
4. componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。
5. unbind：只调用一次，指令与元素解绑时调用。

钩子函数第一个参数是被绑定的原生DOM元素，第二个元素是一个binding对象，该对象有三个重要的属性name、value和expression

#### （2）全局自定义指令

```js
Vue.directive('指令名称',callback)

Vue.directive('focus',{
    // 在内存中就触发了bind，一般用于修改样式
    bind(el, binding, vnode) {
        if(binding.value = 'color') {
    		el.style.focus = 'red'
        }
    },
    // 页面DOM已经渲染完毕，一般用于js控制
    inserted(el,binding) {
        el.focus()
    },
    update(el,binding) {
        console.log('update')
    },
    componentUpdated(el,binding) {
        console.log('componentUpdated')
    },
    unbind(el,binding) {
        console.log('unbind')
    }
})
```

#### （3）局部自定义指令

局部注册通过在组件`options`选项中设置`directive`属性

```js
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus() // 页面加载完成之后自动让输入框获取到焦点的小功能
    }
  }
}
```

#### （4）所有的钩子函数的参数都有以下

- el：指令所绑定的元素，可以用来直接操作 DOM
- binding：一个对象，包含以下 property：
  - name：指令名，不包括 v- 前缀。
  - value：指令的绑定值，例如：v-my-directive="1 + 1" 中，绑定值为 2。
  - oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。
  - expression：字符串形式的指令表达式。例如 v-my-directive="1 + 1" 中，表达式为 "1 + 1"。
  - arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 "foo"。
  - modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }
- vnode：Vue 编译生成的虚拟节点
- oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用

> 除了 el 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 dataset 来进行



## 22. vue的SSR是什么？作用

`SSR`就是服务端渲染

基于`nodejs serve`服务环境开发，所有`html`代码在服务端渲染

数据返回给前端，然后前端进行“激活”，即可成为浏览器识别的html代码

`SSR`首次加载更快，有更好的用户体验，有更好的seo优化，因为爬虫能看到整个页面的内容，如果是vue项目，由于数据还要经过解析，这就造成爬虫并不会等待你的数据加载完成，所以其实Vue项目的seo体验并不是很好



## 23. 路由有哪些模式呢？又有什么不同呢？

- hash模式：通过`#号`后面的内容的更改，触发`hashchange`事件，实现路由切换
- history模式：通过`pushState`和`replaceState`切换url，实现路由切换，需要后端配合

## 24. 动态指令和参数

```js
<template>
    ...
    <aButton @[someEvent]="handleSomeEvent()" :[someProps]="1000" />...
</template>
<script>
  ...
  data(){
    return{
      ...
      someEvent: someCondition ? "click" : "dbclick",
      someProps: someCondition ? "num" : "price"
    }
  },
  methods: {
    handleSomeEvent(){
      // handle some event
    }
  }  
</script>
```



*字节一轮面试---start*

## 25. 手写双向绑定原理

emmm

## 26. 微任务宏任务代码面试题

写出输出打印顺序，并解释为什么

```js
  setTimeout(() => {
    console.log('9)
  },10)
  new Promise((resolve,reject) => {
    // resolve前面是同步任务
    console.log(7)
    setTimeout(() => {
      console.log(8)
      resolve()
    },0)
  }).then(() => {
    console.log(6)
  })

  setTimeout(() => {
    console.log(5)
  },0)

  // await后面才是异步，紧跟的函数foo2返回的不是new promise, 因此不是异步
  async function foo1 () {
    console.log(1)
    await foo2()
    console.log(3)
  }
  function foo2() {
    console.log(2)
  }
  foo1()
  console.log(4)
```

## 27. node的事件循环

## 28. Vue的watch实现原理

## 29. Vue2、vue3的响应式原理和区别

## 30. 浏览器从输入url到页面加载完成发生了什么

涉及内容很广，网址dns解析，HTTP缓存机制，服务端和客户端的TCP链接（三次握手），HTTP请求；css，js，html文件资源解析，构建DOM树，四次挥手

## 31.  算法题

请手写一个函数，第一个参数为二维数组，第二个参数为一个数字；

若在数组里找到该数字则输出true，否则输出false

二维数组的特点：每一行的数字递增，每一列的数字递减；

*（请根据二维数组特点写，不能使用暴力解法）*

```
输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3
输出：true
```

*字节一轮面试---end*



## 32. undefined和null的区别

定义

- undefined：是所有没有赋值变量的默认值，自动赋值


- null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址



1. undefined和null都是原始类型，保存在栈中变量本地
2. undefined表示声明了变量，但是没有对该变量赋值
3. null表示不存在，是人为进行赋值的。比如某个函数或者数组等等复杂类型，你如果想要进行一个舍弃，可以把它赋值为null，此时GC会进行一个回收。一般用于主动释放指向对象的引用。
4.  他们两个是基本相等的，但是不全等。
5. undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：
   - 变量被声明了，但没有赋值时，就等于 undefined
   - 调用函数时，应该提供的参数没有提供，该参数等于 undefined
   - 对象没有赋值的属性，该属性的值为 undefined
   - 函数没有返回值时，默认返回 undefined

5. null用来表示尚未存在的对象，常用来表示函数返回一个不存在的对象。典型用法是：
   - 作为函数的参数，表示该函数的参数不是对象
   - 作为对象原型链的终点

6. null和undefined转换成number数据类型

   - null 默认转成 0
   - undefined 默认转成 NaN

   

## 33. http的缓存机制（服务端的缓存策略）

#### （1）强制缓存

客户端向服务端第一次请求资源，服务端返回资源，服务器response header响应头设置缓存Cache-Control；max-age：3153600

如果不希望缓存就设置no-cache

客户端会根据响应头是否需要缓存资源到本地，所以资源是否需要缓存都是由服务端决定的

![image-20220224090455799](@alias/image-20220224090455799.png)

![image-20220224090521304](@alias/image-20220224090521304.png)

#### （2）协商缓存（对比缓存）

客户端向服务端请求资源，如果服务端认为这些资源可以缓存的话，就会返回资源和资源标识；

客户端后续发送请求带上资源标识，服务端根据资源标识判断资源是否有更新过，如果更新过，则返回200状态码、最新的资源和资源标识；如果是最新的资源了（没有更新过），服务端返回304状态码即可（响应体很小），客户端则直接从缓存里拿资源。

![image-20220224091034721](@alias/image-20220224091034721.png)

![image-20220224084319810](@alias/image-20220224084319810.png)

https://www.bilibili.com/video/BV17Q4y127We?p=4

https://www.cnblogs.com/chenqf/p/6386163.html

#### （3）客户端的资源标识（请求头）

- If-Modified-Since：拿到服务端请求的数据时同时会拿到资源的修改时间（也就是服务端拿到的Last-Modified），再次请求的时候会带上
- If-None-Match：资源对应的唯一字符串，请求时带上，服务端会把它与ETag比较是否一样，一样则走304，不一样就重新请求

#### （4）服务端的资源标识（响应头）

- Last-Modified：资源上一次修改的时间
- ETag：资源的唯一字符串

#### （5）ETag与Last-Modified的区别

**优先使用ETag**

1. 因为Last-Modified的值只会精确到秒级，不够精确，js文件修改一般以毫秒为单位。

1. 文件如果每隔一段时间都有重复生成，但内容相同，Last-Modified也会返回资源文件，即使内容相同（因为修改时间更新了），但是ETag可以判断出文件内容相同，就会返回304，使用缓存。



## 34. TS里interface和type的区别

#### （1）都可以描述对象和函数

```ts
interface User {
    name: string
    age: number
}
interface SetUser {
    (name: string, age: number): void;
}
type User {
    name: string
    age:number
}
type SetUser = (name: string, age: number) =>void;
```

#### （2）都允许拓展（extends）

interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说 interface 可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。

1. interface extends interface
2. type extends type
3. interface extends type

```tsx
type Name = { 
  name: string; 
}
interface User extends Name { 
  age: number; 
}
```

4. type extends interface

```tsx
interface Name { 
  name: string; 
}
type User = Name & { 
  age: number; 
}
```

#### （3）不同点

- type 可以声明基本类型别名，联合类型，元组等类型，interface不可以
- type 语句中还可以使用 typeof 获取实例的 类型进行赋值，interface不可以
- interface 能够声明合并而type不行

## 25. table表格数据很多的时候性能低，有什么办法解决吗？

## 26. 说说比较有成就的项目，说说你觉得的比较难的地方，最后是怎么解决的

## 27. vue的生命周期

## 28. vue模板的渲染过程

## 29. 前端页面性能优化有哪些

## 30. 如何优化SEO

## 31. vue2和vue3的最大区别，性能上有什么变化

## 32. 如何提高webpack打包速度，讲一下打包过程

## 33. webpack如何加快热更新

## 34. 说说vue-router的使用，讲一下路由钩子函数，beforeEach的实现原理

## 35. 说说SSR服务端渲染是怎么实现的

## 36. 路由懒加载如何实现的？

## 37. 说说你知道的JavaScript底层原理

## 38. 从零搭建项目，需要做什么准备

## 39. 华为OD编程题

#### （1）任务总执行时长

#### （2）最小调整顺序次数

#### （3）计算机网络信号















