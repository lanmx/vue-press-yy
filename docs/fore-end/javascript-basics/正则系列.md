正则表达式
==========================

| 第二阶段第四部分 |
| --- |
| Author：周乐|

[TOC]

## 动机

1. 文本处理已经成为计算机常见工作之一

2. 对文本内容的搜索，定位，提取是逻辑比较复杂的工作

3. 为了快速方便的解决上述问题，产生了正则表达式技术

## 简介

1. 定义

> 即文本的高级匹配模式，提供搜索，替换等功能。其本质是由一系列字符和特殊符号构成的字串，这个字串即正则表达式。

2. 原理

> 通过普通字符和有特定含义的字符，来组成字符串，用以描述一定的字符串规则，比如：重复，位置等，来表达某类特定的字符串，进而匹配。

3. 目标

* 熟练掌握正则表达式元字符

* 能够读懂常用正则表达式，编辑简单的正则规则

* 能够熟练使用re模块操作正则表达式



## 元字符使用

#### 普通字符

* 匹配规则：每个普通字符匹配其对应的字符

```
e.g.
In : re.findall('ab',"abcdefabcd")
Out: ['ab', 'ab']
```

* 注意事项：正则表达式在python中也可以匹配中文

#### 或关系

* 元字符: | 

* 匹配规则: 匹配 | 两侧任意的正则表达式即可

```
e.g.
In : re.findall('com|cn',"www.baidu.com/www.tmooc.cn")
Out: ['com', 'cn']

```

#### 匹配单个字符

* 元字符： . 

* 匹配规则：匹配除换行外的任意一个字符

```
e.g.
In : re.findall('张.丰',"张三丰,张四丰,张五丰")
Out: ['张三丰', '张四丰', '张五丰']

```

#### 匹配字符集

* 元字符： [字符集]

* 匹配规则: 匹配字符集中的任意**一个**字符

* 表达形式: 

>> [abc#!好] 表示 [] 中的任意一个字符
>> [0-9],[a-z],[A-Z] 表示区间内的任意一个字符
>> [_#?0-9a-z]  混合书写，一般区间表达写在后面

```
e.g.
In : re.findall('[aeiou]',"How are you!")
Out: ['o', 'a', 'e', 'o', 'u']
```

#### 匹配字符集反集（必须放在中括号里的）

* 元字符：[^字符集]

* 匹配规则：匹配除了字符集以外的任意一个字符（取反）

```
e.g.
In : re.findall('[^0-9]',"Use 007 port")
Out: ['U', 's', 'e', ' ', ' ', 'p', 'o', 'r', 't']
```

#### 匹配字符串开始位置

* 元字符: ^

* 匹配规则：匹配目标字符串的开头位置

```
e.g.
In : re.findall('^Jame',"Jame,hello")
Out: ['Jame']
```

#### 匹配字符串的结束位置

* 元字符:  $

* 匹配规则: 匹配目标字符串的结尾位置

```
e.g.
In : re.findall('Jame$',"Hi,Jame")
Out: ['Jame']
```

* 规则技巧: **^ 和 $必然出现在正则表达式的开头和结尾处。如果两者同时出现，则中间的部分必须匹配整个目标字符串的全部内容。**

## 匹配多个字符

#### 匹配字符重复

* 元字符: * （**可有可无，有出现多次）**

* 匹配规则：匹配前面的字符出现0次或多次

```
e.g.
In : re.findall('wo*',"wooooo~~w!")
Out: ['wooooo', 'w']
```
--------------------

练习：  提取下列语句  How are you

​	re.findall('[a-zA-Z]*','How are you')

​	匹配大写字母开头的单词

re.findall('[A-Z] [a-z]*','How are you, Fine)



* 元字符：+  **（一定要有的）**
* 匹配规则： 匹配前面的字符出现1次或多次

```
e.g.
In : re.findall('[A-Z][a-z]+',"Hello World")
Out: ['Hello', 'World']
```
--------------------
* 元字符：? **（表示可有可无，有必须只能一个）**

* 匹配规则： 匹配前面的字符出现0次或1次

```
e.g. 匹配整数
In [28]: re.findall('-?[0-9]+',"Jame,age:18, -26")
Out[28]: ['18', '-26']
```

-----------------------
练习：

匹配数字(全部数字)

re.findall('-?[0-9]+','167 -28 29 -8')

全部匹配出来

re.findall('[^ ]+','Port-9 Error #404# %@STD')

```
content = """sdfasdfk
fwfasdf
sdfkak
fsldkjfalk
fsdlkafjl"""

用正则表达式匹配所有(因为.不能匹配到\n换行，加一个模块里的方法作为参数就好了)
re.findall(".*",content,re.S)  #大写S
```



* 元字符：{n}
* 匹配规则： 匹配前面的字符出现n次(固定次数)

```
e.g. 匹配手机号码
In : re.findall('1[0-9]{10}',"Jame:13886495728")  #[0-9]{10}  数字出现10次
Out: ['13886495728']

#匹配名字
re.findall('周.{2}','周杰伦','周志伟')
```
-----------------------
* 元字符：{m,n}

* 匹配规则： 匹配前面的字符出现m到n次

```
e.g. 匹配qq号
In : re.findall('[1-9][0-9]{5,10}',"Baron:1259296994") 
Out: ['1259296994']

re.findall('速度与激情\d{1,2}','速度与激情8速度与激情9
速度与激情48速度与激情45')
```

#### 匹配任意（非）数字字符

* 元字符： \d   \D

* 匹配规则：\d 匹配任意数字字符（等同于[0-9]），\D 匹配任意非数字字符（等同于[^0-9]

```
e.g. 匹配端口
In : re.findall('\d{1,5}',"Mysql: 3306, http:80")
Out: ['3306', '80']
```

#### 匹配任意（非）普通字符

* 元字符： \w   \W

* 匹配规则: \w 匹配普通字符，\W 匹配非普通字符

* 说明: **普通字符指数字，字母，下划线，汉字**。

```
e.g.
In : re.findall('\w+',"server_port = 8888")
Out: ['server_port', '8888']
```

#### 匹配任意（非）空字符

* 元字符： \s   \S

* 匹配规则: \s 匹配空字符，\S 匹配非空字符

* 说明：空字符指 空格 \r \n \t \v \f 字符

```
e.g.
In : re.findall('\w+\s+\w+',"hello    world")
Out: ['hello    world']
```

#### 匹配开头结尾位置 \A   \Z

* 元字符： \A   \Z

* 匹配规则： \A 表示开头位置（等同于^），\Z 表示结尾位置(等同于$)

#### 匹配（非）单词的边界位置\b   \B

* 元字符： \b   \B

* 匹配规则： \b 表示单词边界，\B 表示非单词边界

* 说明：单词边界指**数字字母(汉字)下划线与其他字符的交界位置**。（\w所代表的与其他字符的交界）

```
e.g.
In : re.findall(r'\bis\b',"This is a test.")   #\bis\b  （is 两边都是边界，只有第二个is两边处于与空格的边界）
Out: ['is']
```

| 类别     | 元字符                         |
| ------     | --------------                   |
| 匹配字符  | . [...] [^...] \d \D \w \W \s \S |
| 匹配重复 | * +  ?  {n}  {m,n}               |
| 匹配位置 | ^  $  \A  \Z  \b  \B            |
| 其他     | `|`   ()    \                      |

```
st = re.findall('-?\d+\.?\d*','12,-36,28,1.34,-3.14')
print(st)
```

## 正则表达式的转义

1. 如果使用正则表达式匹配特殊字符则需要加 \ 表示转义。

>>特殊字符: . * + ? ^ $ [] () {} | \

```
e.g. 匹配特殊字符 . 时使用 \. 表示本身含义
In : re.findall('-?\d+\.?\d*',"123,-123,1.23,-1.23")
Out: ['123', '-123', '1.23', '-1.23']
```

2. 在编程语言中，常使用原生字符串书写正则表达式避免多重转义的麻烦。

   字符串本身自带转义，如果‘\ $’想变为普通 字符，必须再加一个转义才行

```
e.g.
python字符串  -->    正则    -->    目标字符串
"\\$\\d+"   解析为   \$\d+   匹配   "$100"

"\\$\\d+"  等同于  r"\$\d+"
```

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200408180617235.png" alt="image-20200408180617235" style="zoom: 80%;" />

re.match(pattern, string[, flags]) 

从首字母开始开始匹配，string如果包含pattern子串，则匹配成功，返回Match对象，失败则返回None，若要完全匹配，pattern要以$结尾。



re.findall(pattern, string[, flags]) 
 返回string中所有与pattern相匹配的全部字串，返回形式为数组。



re 模块中的 findall()和match() 一样的功能，其区别是：

​	findall()   如果不满足正则表达式的条件，就返回空列表，反之返回一个列表

  	match()   如果不满足正则表达式的条件，就会返回None，满足返回Match对象，需用Match对象调用group()方法才能显示



### 正则表达式前面最好写上r原生字符串，方便转义

```
"""正则表达式练习1：判断names中的变量命名是否正确"""
import re

names = ['_name','2_name','SDF','name0','_sdf!','a#123']

for name in names:
    ret = re.match(r'^[a-zA-Z_][a-zA-Z0-9]*$',name)  #^匹配[a-zA-Z_]开头的位置是否满足，$匹配[a-zA-Z0-9]*结尾位置是否满足
    if ret:
        print("变量名：%s 符合要求..通过正则表达式匹配出来的数据是：%s" % (name,ret.group()))
    else:
        print("变量名：%s 不符合要求" % name)

```



## 贪婪模式和非贪婪模式

1. 定义

>贪婪模式: 默认情况下，匹配重复的元字符**总是尽可能多的向后匹配内容**。比如: *  +  ?  {m,n}

>非贪婪模式(懒惰模式): **让匹配重复的元字符尽可能少的向后匹配内容**。

2. 贪婪模式转换为非贪婪模式

* 在匹配重复元字符后加 '?' 号即可
```
*  :  *?
+  :  +?
?  :  ??
{m,n} : {m,n}?
```
```
e.g.
In : re.findall(r'\(.+?\)',"(abcd)efgh(higk)")
Out: ['(abcd)', '(higk)']

#贪婪模式（+处理一个或多个，但贪婪模式总会处理多个）
res = '[sdf],[sdaf]'
st = re.findall(r'\[.+\]',res)  #[]是特殊符号，所以需要转义
print(st)  #['[sdf],[sdaf]']

#非贪婪模式(每次匹配一处)
res = '[sdf],[sdaf]'
st = re.findall(r'\[.+?\]',res)  #[]是特殊符号，所以需要转义（括号前后都要加\）
print(st)  #['[sdf]', '[sdaf]']
```

```
"""正则表达式练习"""
#1、匹配一个.com邮箱的格式字符串
import re
email = input("请输入邮箱地址：")
res = re.findall(r'\w+@\w+\.com$',email)  #必须加$，不然多加一个com都不会报错(不严谨)
if res:
    print("输入成功%s" % email)
else:
    print("输入有误，请重新输入")


#2、匹配一个密码，8-12位数字字母下划线构成
import re
password = input("请输入密码：")
res = re.findall(r'[a-zA-Z0-9_]{8,12}',password)  #如果写\w{8，12}的话，不严谨。密码不能中文汉字
if res:
    print("输入成功%s" % password)
else:
    print("输入有误，请重新输入")


#3、匹配一个数字，正数，负数，整数，小数，分数1/2，百分数45%
import re
res = '12, 15, -45, 0, 1.34, 5/6, 56%,hh,哇,#$'
st = re.findall(r'-?\d+/?\.?\d*%?',res)  # - . / % 都是可有可无，0是表示第二部分数字用*表示，可没有可多个
print(st)

#4、匹配一段文字中以大写字母开头的单词，注意文字中
#可能有 iPython(不算）  H-base(算），单词可能有 大写字母 小写字母 -_

import re
msg = """In this column, we will iPython have a section called Wit and Fun, in which we will present some English puzzles, 
humorous stories and games. We will also have a section called Tips on Learning English, 
where you can share your successful  Me--too learning experience with others. Besides, in the section — I Say, You Say, 
different  UFO opinions  I on hot topics and phenomena will be warmly welcome.
Please send your contributions to the E_ditorial Section or e-mail to: englishcolumn@sina.com.cn. Please remember: 
contributions are expected to be within 500 words.
"""
st = re.findall(r'\b[A-Z][a-zA-Z-_]*',msg)  #将上\b，iPython就不会匹配到。每个单词左边有个边界
print(st)
```



## 正则表达式分组

1. 定义

> **在正则表达式中，以()建立正则表达式的内部分组，子组是正则表达式的一部分，可以作为内部整体操作对象。**

2. 作用

* 可以被作为整体操作，改变元字符的操作对象

```
e.g.  改变 +号 重复的对象
In : re.search(r'(ab)+',"ababababab").group()
Out: 'ababababab'

e.g. 改变 |号 操作对象
In : re.search(r'(王|李)\w{1,3}',"王者荣耀").group()
Out: '王者荣耀'
```

* 可以通过编程语言某些接口获取匹配内容中，子组对应的内容部分

```
e.g. 获取url协议类型
In : re.search(r'(https|http|ftp|file)://\S+',"https://www.baidu.com").group(1)
Out: https

```

3. 捕获组

可以给正则表达式的子组起一个名字，表达该子组的意义。这种有名称的子组即为捕获组。

>格式：`(?P<name>pattern)`

```
e.g. 给子组命名为 "pig"
In : re.search(r'(?P<pig>ab)+',"ababababab").group('pig')
Out: 'ab'

```

4. 注意事项

* 一个正则表达式中可以包含多个子组
* 子组可以嵌套，但是不要重叠或者嵌套结构复杂
* 子组序列号一般从外到内，从左到右计数

<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200409135127607.png" alt="image-20200409135127607" style="zoom:50%;" />

```
"""正则表达式练习2：匹配出163的邮箱地址，且@符号之前有4~20位，例如：hello@163.com"""
import re

mail = input("请输入邮箱地址：")

#如果在正则表达式中需要用到了某些普通的字符，比如 . 比如 ？ 等，就需要在他们前面加一个反斜杠进行转义（避免冲突）
res = re.match(r'[a-zA-Z0-9]{4,20}@163\.com$',mail)   #match自带^开头位置，可不用写
if res:
    print("%s输入成功"% res.group())

else:
    print("输入有误，请重新输入")

res = re.match(r'^[a-zA-Z0-9]{4,20}@(163|162)\.com$','sdf145132@163.com')  #小括号可以缩小范围,一个小括号称为一个分组

print(res.group(1))   #里面的参数表示正则表达式里的第一个分组

res = re.match(r'(^[a-zA-Z0-9]{4,20})@(163|162)\.com$','sdf145132@163.com')
print(res.group(1))   #取出@前面的账号sdf145132
print(res.group(2))   #取出表名地址163

"""判断标签是否正确<h1>sdfa</h1>    两边的<>里需一样"""
# ra = '<h1>sdfa</h2>'  #标签不正确，报错
ra = '<h1>sdfa</h1>'
res = re.match(r'<(\w*)>.*</\1>',ra)   #\1表示第一个分组的值
print(res.group())


#扩展知识
ra = '<h1>sdfa</h1>'
res = re.match(r'<(?P<p1>\w*)>.*</(?P=p1)>',ra)   #给分组取名字，字母P是大写
print(res.group())	
```

## 正则表达式匹配原则

1. 正确性,能够正确的匹配出目标字符串.
2. 排他性,除了目标字符串之外尽可能少的匹配其他内容.
3. 全面性,尽可能考虑到目标字符串的所有情况,不遗漏.

## Python re模块使用

***参考代码day13/regex.py***

----------------------

```python
 regex = compile(pattern,flags = 0)
 功能: 生产正则表达式对象
 参数: pattern  正则表达式
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 正则表达式对象
```
------------------------
```python
 re.findall(pattern,string,flags = 0)
 功能: 根据正则表达式匹配目标字符串内容
 参数: pattern  正则表达式
      string 目标字符串
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 匹配到的内容列表,如果正则表达式有子组则只能获取到子组对应的内容,多个子组的话就一个【（）（）】
```
------------------------
```python
 regex.findall(string,pos,endpos)
 功能: 根据正则表达式匹配目标字符串内容
 参数: string 目标字符串
      pos 截取目标字符串的开始匹配位置
      endpos 截取目标字符串的结束匹配位置
 返回值: 匹配到的内容列表,如果正则表达式有子组则只能获取到子组对应的内容
```
------------------------
 ```python
 re.split(pattern,string,flags = 0)
 功能: 使用正则表达式匹配内容,切割目标字符串
 参数: pattern  正则表达式
      string 目标字符串
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 切割后的内容列表
 ```
------------------------
<img src="C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20200408201901865.png" alt="image-20200408201901865" style="zoom:50%;" />

```python
 re.sub(pattern,replace,string,count,flags = 0)
 功能: 使用一个字符串替换正则表达式匹配到的内容
 参数: pattern  正则表达式
      replace  替换的字符串
      string 目标字符串
      max  最多替换几处,默认替换全部
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 替换后的字符串
```
------------------------

```python
#与sub基本一样，不过返回值多了一个替换几处
re.subn(pattern,replace,string,count,flags = 0)
 功能: 使用一个字符串替换正则表达式匹配到的内容
 参数: pattern  正则表达式
      replace  替换的字符串
      string 目标字符串
      max  最多替换几处,默认替换全部
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 替换后的字符串和替换了几处
```
------------------------
***参考代码day13/regex1.py***

```python
 re.finditer(pattern,string,flags = 0)
 功能: 根据正则表达式匹配目标字符串内容
 参数: pattern  正则表达式
      string 目标字符串
      flags  功能标志位,扩展正则表达式的匹配
 返回值: 匹配结果的迭代器
```
------------------------
```python
re.fullmatch(pattern,string,flags=0)   #相当于前后加了一个^$
功能：完全匹配某个目标字符串
参数：pattern 正则
	string  目标字符串
返回值：匹配内容match object
```
------------------------
```python
re.match(pattern,string,flags=0)    #相当于在前加了一个^
功能：匹配某个目标字符串开始位置    
参数：pattern 正则
	string  目标字符串
返回值：匹配内容match object
```
------------------------
```python
re.search(pattern,string,flags=0)
功能：匹配目标字符串第一个符合内容
参数：pattern 正则
	string  目标字符串
返回值：匹配内容match object
```



​					search()  不用重头开始，只要有匹配的值就立马结束

compile对象属性
	  
	【1】 pattern ： 正则表达式
	【2】 groups ： 子组数量
	【3】 groupindex ： 捕获组名与组序号的字典

------------------------

### match对象的属性方法

***参考代码day13/regex2.py***

1. 属性变量
	
* pos   匹配的目标字符串开始位置
* endpos  匹配的目标字符串结束位置
* re     正则表达式
* string  目标字符串
* lastgroup  最后一组的名称
* lastindex  最后一组的序号
	
2. 属性方法
	
* span()  获取匹配内容的起止位置

* start() 获取匹配内容的开始位置

* end()   获取匹配内容的结束位置

* groupdict()  获取捕获组字典，组名为键，对应内容为值

* groups() 获取子组对应内容，子组个数
  
* group(n = 0)

	  功能：获取match对象匹配内容
	  参数：默认为0表示获取整个match对象内容，如果是序列号或者组名则表示获取对应子组内容
	  返回值：匹配字符串


### flags参数扩展

***参考代码day13/flags.py***

  1. 使用函数：re模块调用的匹配函数。如：re.compile,re.findall,re.search....

  2. 作用：扩展丰富正则表达式的匹配功能

  3. 常用flag
	
> A == ASCII  元字符只能匹配ascii码

> I == IGNORECASE  匹配忽略字母大小写

> S == DOTALL  使 . 可以匹配换行

> M == MULTILINE  使 ^  $可以匹配每一行的开头结尾位置

  4. 使用多个flag
	
     方法：使用按位或连接  
	  e.g. ：  flags = re.I | re.A

## 常用正则表达式

```js
验证数字：^[0-9]*$

验证n位的数字：^\d{n}$

验证至少n位数字：^\d{n,}$

验证m-n位的数字：^\d{m,n}$

验证零和非零开头的数字：^(0|[1-9][0-9]*)$
              
验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$
             
验证有1-3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$
             
验证非零的正整数：^\+?[1-9][0-9]*$
             
验证非零的负整数：^\-[1-9][0-9]*$
             
验证非负整数（正整数 + 0） ^\d+$
             
验证非正整数（负整数 + 0） ^((-\d+)|(0+))$

验证长度为3的字符：^.{3}$

验证由26个英文字母组成的字符串：^[A-Za-z]+$
             
验证由26个大写英文字母组成的字符串：^[A-Z]+$
             
验证由26个小写英文字母组成的字符串：^[a-z]+$
             
验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$
             
验证由数字、26个英文字母或者下划线组成的字符串：^\w+$
             
验证用户名：/^[A-Za-z]{1}[A-Za-z0-9_-]{3,15}$/ 格式内容为：以字母开头，只能包含字母数字下划线和减号，4到16位
             
验证用户密码1:^[a-zA-Z]\w{5,17}$ 正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。

验证密码强度：/(?=^.{6,16}$)(?=.*\d)(?=.*[A-Z])(?=.*[a-z])(?=.*[!@#$%^&*]).*$/ 格式内容为：6-16位，,至少有一个数字，一个大写字母，一个小写字母和一个特殊字符，四个任意组合
                                                    
验证用户密码2：^(.{0,5}|.{21,})$|^[^\d]*$|^[^a-zA-Z]*$|\s 格式内容为：以字母数字开头，无空格，6-20位之间

验证是否含有 ^%&',;=?$\" 等字符：[^%&',;=?$\x22]+
    
验证汉字：^[\u4e00-\u9fa5],{0,}$
       
验证Email地址：^\w+[-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$
                   
验证邮箱：/^[a-z0-9]{1}[a-z0-9_-]{1,}@[a-z0-9]{1,}(\.[a-z]{2,})*\.[a-z]{2,}$/ 格式内容为：必须有@，前边最少2个字符，字母或数字开头，域名部分最少1位，后缀可以是一级也可以是二级，最少两位 （email = email.toLowerCase();// 全部转小写（邮箱不区分大小写），验证前可以先把输入的邮箱地址转成小写）
                                                                   
验证邮箱2 ：/^[a-zA-Z0-9]{1}[\w|\-|\.|\_]{1,31}@[a-zA-Z0-9]+\.[a-zA-Z0-9]*\.*([a-zA-Z]{2,4})$/ 格式内容为：开头字母数字，非下划线（1位）接下来的 字母、数字、下划线、点、减号（31位） @紧跟着字母数字下划线减号（数量无限制） .后面2-4位 一般为（.com .cn .net）
                                          
验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$

验证手机号码： /^1[3456789]\d{9}$/
    
验证电话号码：^(\d3,4|\d{3,4}-)?\d{7,8}$：--正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。
                             
验证身份证：/^[1-9]{1}\d{5}[1-9]{2}\d{9}[Xx0-9]{1}$/ 格式内容为：身份证号：前两位表示地区，所以第一位不可能是0，而第7、8两位是年份的前两位，也不可能是0，最后一位除了10个数字以外还可能是X|x

验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12”
            
验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。

整数：^-?\d+$

非负浮点数（正浮点数 + 0）：^\d+(\.\d+)?$
                     
正浮点数 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$

非正浮点数（负浮点数 + 0） ^((-\d+(\.\d+)?)|(0+(\.0+)?))$
                  
负浮点数 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$

浮点数 ^(-?\d+)(\.\d+)?$
```

<Valine></Valine>